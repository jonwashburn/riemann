import Mathlib

/-!
# Recognition Geometry (RG)
## The Axiomatic Foundation

This formalization vindicates the core insight of Recognition Geometry:
**"Space is not a stage; it is a result."**

We treat *recognition* (measurement) as the primitive operation. Geometric structure
(topology, observable points, metrics) is derived as the quotient of a configuration
space by observational indistinguishability.

### Module Structure
1.  **Primitives**: `ConfigSpace`, `EventSpace`, `LocalityStructure`.
2.  **Topology**: Generation of `TopologicalSpace` from locality primitives.
3.  **Recognition**: `Recognizer`, `Indistinguishable`, `RecognitionQuotient`.
4.  **Composition**: `âŠ—` operator, Refinement Theorem.
5.  **Finite Resolution**: Finite Local Resolution (RG3) and the No-Injection Theorem.
6.  **Symmetry**: Automorphism groups and Gauge Equivalence.
7.  **Metrization**: Emergence of `PseudoMetricSpace` from comparative recognition.
-/

namespace RecognitionGeometry

open Set Filter Topology Function

/-! =========================================================================
    1. Primitives (RG0, RG1, RG2)
    ========================================================================= -/

/-- **RG0**: The Configuration Space is a nonempty set of states. -/
class ConfigSpace (C : Type*) where
  [nonempty : Nonempty C]

attribute [instance] ConfigSpace.nonempty

/-- **RG1**: The Event Space contains at least two distinct outcomes. -/
class EventSpace (E : Type*) where
  [nontrivial : Nontrivial E]

attribute [instance] EventSpace.nontrivial

/-- **RG2**: A Locality Structure `N` assigns to each configuration `c` a family of
    subsets `N(c)` representing "locally accessible" regions.
    Mathematically, `N(c)` forms a filter basis for the neighborhoods of `c`. -/
structure LocalityStructure (C : Type*) where
  N : C â†’ Set (Set C)
  /-- Reflexivity: An observer at `c` is contained in all local neighborhoods of `c`. -/
  mem_of_mem_nhds : âˆ€ c, âˆ€ U âˆˆ N c, c âˆˆ U
  /-- Intersection: Two neighborhoods can be refined by a third. -/
  inter_nhds : âˆ€ c, âˆ€ U V, U âˆˆ N c â†’ V âˆˆ N c â†’ âˆƒ W âˆˆ N c, W âŠ† U âˆ© V
  /-- Existence: Every point has at least one neighborhood. -/
  nhds_nonempty : âˆ€ c, (N c).Nonempty

/-! =========================================================================
    2. Derived Topology
    ========================================================================= -/

variable {C E : Type*} [ConfigSpace C] [EventSpace E]

/-- **Definition 1**: The topology generated by a Locality Structure.
    A set is open iff it contains a local neighborhood for every point inside it. -/
def LocalityStructure.toTopology (L : LocalityStructure C) : TopologicalSpace C where
  IsOpen U := âˆ€ x âˆˆ U, âˆƒ V âˆˆ L.N x, V âŠ† U
  isOpen_univ := fun x _ =>
    let âŸ¨V, hVâŸ© := L.nhds_nonempty x
    âŸ¨V, hV, subset_univ VâŸ©
  isOpen_inter := fun S T hS hT x âŸ¨hxS, hxTâŸ© => by
    obtain âŸ¨U, hU, hU_subâŸ© := hS x hxS
    obtain âŸ¨V, hV, hV_subâŸ© := hT x hxT
    obtain âŸ¨W, hW, hW_subâŸ© := L.inter_nhds x U V hU hV
    exact âŸ¨W, hW, Subset.trans hW_sub (inter_subset_inter hU_sub hV_sub)âŸ©
  isOpen_sUnion := fun S hS x âŸ¨T, hT_in, hxTâŸ© => by
    obtain âŸ¨V, hV, hV_subâŸ© := hS T hT_in x hxT
    exact âŸ¨V, hV, Subset.trans hV_sub (subset_sUnion_of_mem hT_in)âŸ©

/-- **Insight**: The locality structure `N(c)` precisely generates the
    neighborhood filter in the induced topology. -/
theorem LocalityStructure.nhds_hasBasis (L : LocalityStructure C) (c : C) :
    let _ := L.toTopology
    (ð“ c).HasBasis (fun U => U âˆˆ L.N c) id := by
  let _ := L.toTopology
  apply (hasBasis_nhds_of_basis (L.toTopology.to_hasBasis) ?_ ?_ ?_ ?_).congr
  Â· exact fun U hU => âŸ¨U, hU, rfl.subsetâŸ©
  Â· exact L.inter_nhds c
  Â· exact L.mem_of_mem_nhds c
  Â· exact fun U hU => hU c

/-! =========================================================================
    3. Recognition and Quotients
    ========================================================================= -/

/-- **Definition 2**: A Recognizer is a map to an event space with a non-trivial image. -/
structure Recognizer (C E : Type*) where
  toFun : C â†’ E
  nontrivial_range : Nontrivial (range toFun)

instance : CoeFun (Recognizer C E) (fun _ => C â†’ E) := âŸ¨Recognizer.toFunâŸ©

/-- **Definition 4**: Two configurations are indistinguishable if they produce the same event. -/
def Indistinguishable (R : Recognizer C E) (x y : C) : Prop := R x = R y

/-- Indistinguishability forms an equivalence relation (Setoid). -/
instance instRecognizerSetoid (R : Recognizer C E) : Setoid C where
  r := Indistinguishable R
  iseqv := âŸ¨fun _ => rfl, fun h => h.symm, fun h1 h2 => h1.trans h2âŸ©

/-- **Definition 9**: The Recognition Quotient is the space of observable states. -/
def RecognitionQuotient (R : Recognizer C E) := Quotient (instRecognizerSetoid R)

/-- The canonical projection from configuration space to observable space. -/
def proj (R : Recognizer C E) : C â†’ RecognitionQuotient R := Quotient.mk (instRecognizerSetoid R)

/-- **Theorem 1 (Fundamental)**: The recognizer descends to an *injective* map on the quotient.
    This validates that the quotient captures *exactly* the observable information. -/
def inducedMap (R : Recognizer C E) : RecognitionQuotient R â†’ E :=
  Quotient.lift R (fun _ _ => id)

theorem inducedMap_injective (R : Recognizer C E) : Injective (inducedMap R) := by
  intro x y h
  induction x using Quotient.inductionOn
  induction y using Quotient.inductionOn
  exact Quotient.sound h

/-- **Theorem 2 (Universality)**: Any map $f$ constant on indistinguishable states factors uniquely
    through the recognition quotient. -/
theorem universal_property {X : Type*} (R : Recognizer C E) (f : C â†’ X)
    (h_compat : âˆ€ câ‚ câ‚‚, Indistinguishable R câ‚ câ‚‚ â†’ f câ‚ = f câ‚‚) :
    âˆƒ! F : RecognitionQuotient R â†’ X, F âˆ˜ (proj R) = f := by
  let F := Quotient.lift f h_compat
  refine âŸ¨F, rfl, fun G hG => ?_âŸ©
  ext x; induction x using Quotient.inductionOn
  simp [â† hG]

/-- **Definition 10**: The quotient carries the coinduced topology.
    This is the finest topology making the projection continuous. -/
def RecognitionQuotient.topology (L : LocalityStructure C) (R : Recognizer C E) :
    TopologicalSpace (RecognitionQuotient R) :=
  TopologicalSpace.coinduced (proj R) L.toTopology

/-! =========================================================================
    4. Composition and Refinement
    ========================================================================= -/

section Composition

variable {E1 E2 : Type*} [EventSpace E1] [EventSpace E2]

/-- **Definition 12**: The Composite Recognizer $R_1 \otimes R_2$.
    Observing two events simultaneously yields finer granularity. -/
def compositeRecognizer (R1 : Recognizer C E1) (R2 : Recognizer C E2) :
    Recognizer C (E1 Ã— E2) where
  toFun := fun c => (R1 c, R2 c)
  nontrivial_range := by
    -- Proof that if R1 is nontrivial, the pair is nontrivial
    obtain âŸ¨_, âŸ¨c1, rflâŸ©, âŸ¨c2, rflâŸ©, h_diffâŸ© := R1.nontrivial_range
    use (R1 c1, R2 c1), (R1 c2, R2 c2)
    simp; exists c1; exists c2
    intro h; exact h_diff (Prod.mk.inj_iff.mp h).1

infix:60 " âŠ— " => compositeRecognizer

/-- **Theorem 3**: Composite Indistinguishability is the conjunction of component indistinguishability. -/
theorem composite_indistinguishable_iff (R1 : Recognizer C E1) (R2 : Recognizer C E2) (x y : C) :
    Indistinguishable (R1 âŠ— R2) x y â†” Indistinguishable R1 x y âˆ§ Indistinguishable R2 x y := by
  simp [Indistinguishable, compositeRecognizer]

/-- **Theorem 4 (Refinement)**: The composite quotient naturally refines the component quotients.
    There exists a canonical surjective map from $C_{R_1 \otimes R_2}$ to $C_{R_1}$. -/
def refinementMap (R1 : Recognizer C E1) (R2 : Recognizer C E2) :
    RecognitionQuotient (R1 âŠ— R2) â†’ RecognitionQuotient R1 :=
  Quotient.map id (fun _ _ h => (composite_indistinguishable_iff R1 R2 _ _).mp h).1

theorem refinementMap_surjective (R1 : Recognizer C E1) (R2 : Recognizer C E2) :
    Surjective (refinementMap R1 R2) := by
  intro q; induction q using Quotient.inductionOn
  exact âŸ¨Quotient.mk _ _, rflâŸ©

end Composition

/-! =========================================================================
    5. Finite Resolution (RG3)
    ========================================================================= -/

variable (L : LocalityStructure C)

/-- **RG3**: Finite Local Resolution.
    A recognizer has finite resolution if every point has a neighborhood mapping to a finite set. -/
class FiniteLocalResolution : Prop where
  finite_res : âˆ€ (c : C) (R : Recognizer C E), âˆƒ U âˆˆ L.N c, (R '' U).Finite

/-- **Theorem 7 (Local Non-Injectivity)**:
    If a neighborhood is infinite but the recognizer has finite resolution there,
    the recognizer cannot be injective. This formalizes the "pixelation" limit. -/
theorem local_non_injectivity
    (R : Recognizer C E) (c : C) (U : Set C)
    (h_nhd : U âˆˆ L.N c)
    (h_finite_res : (R '' U).Finite)
    (h_infinite_nhd : U.Infinite) :
    Â¬ Injective (R âˆ˜ Subtype.val : U â†’ E) := by
  intro h_inj
  -- We construct the corestriction f : U â†’ Im(R|U)
  let f : U â†’ R '' U := fun x => âŸ¨R x, mem_image_of_mem R x.2âŸ©
  -- If R|U is injective, f is bijective onto its image
  have h_f_inj : Injective f := fun x y h =>
    Subtype.ext_iff.mp (h_inj (congrArg Subtype.val h))
  -- An injective map from an infinite set to a finite set contradicts cardinality
  haveI : Finite (R '' U) := h_finite_res.to_subtype
  have h_finite_dom : Finite U := Finite.of_injective f h_f_inj
  exact h_infinite_nhd (finite_coe_iff.mp h_finite_dom)

/-! =========================================================================
    6. Symmetry and Gauge
    ========================================================================= -/

variable (R : Recognizer C E)

/-- **Definition 13**: A map is Recognition Preserving if it leaves all events invariant. -/
def IsRecognitionPreserving (Ïƒ : C â†’ C) : Prop := âˆ€ c, R (Ïƒ c) = R c

/-- **Definition 14**: The group of Recognition Automorphisms `Aut_R(C)`.
    Defined as a subgroup of the permutation group `Equiv.Perm C`. -/
def RecognitionAutomorphism : Subgroup (Equiv.Perm C) where
  carrier := { Ïƒ | IsRecognitionPreserving R Ïƒ }
  one_mem' := fun _ => rfl
  mul_mem' := fun hf hg c => by
    -- (f * g)(c) = f(g(c))
    simp [IsRecognitionPreserving, Equiv.Perm.mul_apply] at *
    rw [hg, hf]
  inv_mem' := fun {f} hf c => by
    -- R(fâ»Â¹(c)) = R(c) via R(f(fâ»Â¹(c))) = R(c)
    rw [â† hf (f.symm c), f.apply_symm_apply]

/-- **Definition 15**: Gauge Equivalence is the orbit relation of the Automorphism group. -/
def GaugeEquivalent (x y : C) : Prop :=
  âˆƒ Ïƒ : RecognitionAutomorphism R, Ïƒ.1 x = y

/-- **Theorem 6**: Gauge symmetry implies observational indistinguishability.
    (Symmetries preserve events, so symmetric states are indistinguishable). -/
theorem gauge_implies_indistinguishable (x y : C) :
    GaugeEquivalent R x y â†’ Indistinguishable R x y := by
  rintro âŸ¨Ïƒ, rflâŸ©
  exact (Ïƒ.2 x).symm

/-! =========================================================================
    7. Metrization (RG4)
    ========================================================================= -/

/-- **RG4**: Comparative Recognizers map pairs of points to events (comparisons). -/
structure ComparativeRecognizer (C E : Type*) where
  comp : C â†’ C â†’ E
  e_eq : E
  refl_eq : âˆ€ c, comp c c = e_eq

/-- **Example 9**: Discrete Recognition Distance.
    Constructs a pseudometric from a family of comparative recognizers.
    This demonstrates the "Emergence of Distance" from recognition. -/
def DiscreteRecognitionDistance
    {Î¹ : Type*}
    (F : Î¹ â†’ ComparativeRecognizer C E) -- A family of comparators
    (E_eq : Î¹ â†’ Set E)                   -- Sets of events interpreted as "equal"
    (h_refl : âˆ€ i c, (F i).comp c c âˆˆ E_eq i)
    (h_symm : âˆ€ i x y, (F i).comp x y âˆˆ E_eq i â†’ (F i).comp y x âˆˆ E_eq i)
    (h_trans : âˆ€ x y z, (âˆ€ i, (F i).comp x y âˆˆ E_eq i) â†’
                        (âˆ€ i, (F i).comp y z âˆˆ E_eq i) â†’
                        (âˆ€ i, (F i).comp x z âˆˆ E_eq i)) :
    PseudoMetricSpace C where
  dist x y := if âˆ€ i, (F i).comp x y âˆˆ E_eq i then 0 else 1
  dist_self x := by simp [h_refl]
  dist_comm x y := by
    by_cases h : âˆ€ i, (F i).comp x y âˆˆ E_eq i
    Â· simp [h]; intro i; exact h_symm i x y (h i)
    Â· have h_ne : Â¬ (âˆ€ i, (F i).comp y x âˆˆ E_eq i) := fun h_rev => h (fun i => h_symm i y x (h_rev i))
      simp [h, h_ne]
  dist_triangle x y z := by
    by_cases hxy : âˆ€ i, (F i).comp x y âˆˆ E_eq i
    Â· by_cases hyz : âˆ€ i, (F i).comp y z âˆˆ E_eq i
      Â· -- Case 0 <= 0 + 0
        simp [hxy, hyz, h_trans x y z hxy hyz]
      Â· -- Case d(x,z) <= 0 + 1 (Trivial)
        simp [hxy, hyz]; split_ifs <;> norm_num
    Â· -- Case d(x,z) <= 1 + d(y,z) (Trivial)
      simp [hxy]; split_ifs <;> norm_num; simp
  edist_dist x y := (ENNReal.ofReal_eq_coe_nnreal _).symm

end RecognitionGeometry
