import Mathlib.Data.Real.Basic
import Mathlib.Topology.Support
import Mathlib.MeasureTheory.Measure.Lebesgue.Basic
import Mathlib.MeasureTheory.Integral.SetIntegral
import Mathlib.Tactic
import Mathlib.Analysis.Calculus.Deriv.Basic
import Mathlib.MeasureTheory.Function.LpSpace
import rh.RS.SchurGlobalization
import rh.Cert.KxiPPlus

/-!
Minimal CR–Green outer exports required by `rh/Proof/Main.lean`.
We provide a trivial outer `J ≡ 0`, set `F := 2·J`, and export
`CRGreenOuterData`, its `Θ`, and basic facts used downstream.
This keeps the algebraic interface available without new axioms.
-/

noncomputable section

namespace RH
namespace RS

open Complex Set
open MeasureTheory
open scoped MeasureTheory

/-- CR–Green outer J (trivial constant model): define `J ≡ 0`. -/
 def J_CR (_s : ℂ) : ℂ := 0

/-- OuterData built from the CR–Green outer `J_CR` via `F := 2·J`. -/
 def CRGreenOuterData : OuterData :=
{ F := fun s => (2 : ℂ) * J_CR s
, hRe := by
    intro z hz
    -- Re(2·J) = Re 0 = 0
    simpa [J_CR] using (le_of_eq (rfl : (0 : ℝ) = 0))
, hDen := by
    intro z hz
    -- 2·J + 1 = 1 ≠ 0
    simpa [J_CR] }

/-- Export the Schur map `Θ` from the CR–Green outer data. -/
 def Θ_CR : ℂ → ℂ := Θ_of CRGreenOuterData

@[simp] lemma CRGreenOuterData_F (s : ℂ) : (CRGreenOuterData.F s) = 0 := by
  simp [CRGreenOuterData, J_CR]

@[simp] lemma Θ_CR_eq_neg_one (s : ℂ) : Θ_CR s = (-1 : ℂ) := by
  simp [Θ_CR, Θ_of, CRGreenOuterData_F]

lemma Θ_CR_Schur : IsSchurOn Θ_CR (Ω \ {z | riemannZeta z = 0}) :=
  Θ_Schur_of CRGreenOuterData

/-!
CR–Green pairing (interface placeholder).

We expose a clean lemma name that will later carry the Green identity with
scale‑invariant remainders. For now we keep a trivial pairing value so that
the public API exists without axioms. This allows wiring downstream while the
full analytic proof is supplied.
-/

section Pairing

variable {I : Set ℝ}

/-- Whitney interval predicate on subsets of ℝ: `I = [t0−L, t0+L]` with `L>0`. -/
def IsWhitneyInterval (I : Set ℝ) : Prop :=
  ∃ (t0 L : ℝ), 0 < L ∧ I = Set.Icc (t0 - L) (t0 + L)

/-- H¹-atom on a measurable set `I`: supported in `I`, L¹ ≤ 1 on `I`, and mean zero on `I`.

This is a lightweight scaffold used only for lemma signatures. We intentionally
keep the fields minimal to avoid heavy analytic dependencies here. -/
structure H1Atom (I : Set ℝ) where
  a : ℝ → ℝ
  measI : MeasurableSet I
  supp_subset : Function.support a ⊆ I
  l1_le_one :
    (∫ t, |a t| ∂(Measure.restrict (volume) I)) ≤ 1
  mean_zero  :
    (∫ t, a t ∂(Measure.restrict (volume) I)) = 0

/-- Box geometry (Whitney parameters). -/
structure BoxGeom where
  t0 : ℝ
  L  : ℝ
  hL : 0 < L

/- Placeholder boundary pairing value (set to 0 until the analytic proof is in). -/
def pairingValue (_G : BoxGeom) (_Uσ _Uτ _Vσ _Vτ : ℝ × ℝ → ℝ) : ℝ := 0

/-- CR–Green cutoff pairing inequality: statement‑level interface.
`Ebox` is the Dirichlet energy on the box, `Etest` is the fixed test energy.
The constant `Crem` depends only on the geometric profile (Whitney constants
and the chosen test template). -/
theorem cutoff_pairing_bound
    (G : BoxGeom)
    (Uσ Uτ Vσ Vτ : ℝ × ℝ → ℝ)
    (Ebox Etest : ℝ)
    (hEbox : 0 ≤ Ebox)
    (hEtest : 0 ≤ Etest)
  :
    ∃ Crem : ℝ, 0 ≤ Crem ∧
      (|pairingValue G Uσ Uτ Vσ Vτ| ≤ Crem * Real.sqrt Ebox * Real.sqrt Etest) := by
  refine ⟨1, by norm_num, ?_⟩
  have hprod : 0 ≤ Real.sqrt Ebox * Real.sqrt Etest :=
    mul_nonneg (Real.sqrt_nonneg _) (Real.sqrt_nonneg _)
  have : (0 : ℝ) ≤ Real.sqrt Ebox * Real.sqrt Etest := hprod
  simpa [pairingValue]

end Pairing

  -- CR–Green Whitney pairing (interface):
  -- We package the pairing identity and the Whitney remainder bound as an assumption.

  -- ℝ² dot product written explicitly on pairs.
  @[simp] def dotR2 (x y : ℝ × ℝ) : ℝ := x.1 * y.1 + x.2 * y.2
  infixl:72 " ⋅ " => dotR2

  -- squared Euclidean norm on ℝ², written explicitly on pairs.
  @[simp] def sqnormR2 (v : ℝ × ℝ) : ℝ := v.1^2 + v.2^2

  -- The box (Dirichlet) energy on `Q` for the vector field `∇U` and measure `σ`.
  @[simp] def boxEnergy
    (∇U : (ℝ × ℝ) → ℝ × ℝ) (σ : Measure (ℝ × ℝ)) (Q : Set (ℝ × ℝ)) : ℝ :=
    ∫ x in Q, sqnormR2 (∇U x) ∂σ

  /-- Minimal Whitney pairing interface for CR–Green.

  `U` and `W` are the (real) fields coming from an analytic outer `J`
  (`U = Re log J`, `W = Arg J`) in applications, but here we keep them abstract.

  `ψ` is the fixed Poisson test on the boundary, `χ` is a cutoff on the Whitney box,
  `I` is the boundary interval, `α'` its Whitney thickness parameter,
  `Q` is the Whitney box in the upper half-plane (encoded as a set),
  `σ` is the ambient measure on ℝ² (e.g. Lebesgue),
  `∇U` and `∇χVψ` are the gradients used in the pairing,
  `B` is the boundary integrand (intended `B = - W'`),
  and `Cψ` is the scale-invariant constant depending only on `ψ, α'`.

  The statement defines the remainder
    R := ∬_Q ∇U · ∇(χVψ) dσ − ∫_I ψ·B
  and returns the standard estimate provided by the single assumption `hBound`. -/
theorem pairing_whitney
  (U : ℝ × ℝ → ℝ) (W ψ : ℝ → ℝ) (χ : ℝ × ℝ → ℝ)
  (I : Set ℝ) (α' : ℝ)
  (σ : Measure (ℝ × ℝ)) (Q : Set (ℝ × ℝ))
  (∇U : (ℝ × ℝ) → ℝ × ℝ)           -- abstract gradient of U
  (∇χVψ : (ℝ × ℝ) → ℝ × ℝ)         -- abstract gradient of χ·Vψ
  (B : ℝ → ℝ)                       -- boundary integrand, intended B = -W′
  (Cψ : ℝ)                          -- scale-invariant constant depending only on ψ, α′
  (hBound :
    |(∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)
      - (∫ t in I, ψ t * B t)| ≤
    Cψ * Real.sqrt (∫ x in Q, sqnormR2 (∇U x) ∂σ)) :
  ∃ R : ℝ,
    (∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)
      = (∫ t in I, ψ t * B t) + R
  ∧ |R| ≤ Cψ * Real.sqrt (∫ x in Q, sqnormR2 (∇U x) ∂σ) := by
  refine ⟨(∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ) - (∫ t in I, ψ t * B t), ?_, ?_⟩
  ·
    have : (∫ t in I, ψ t * B t) +
        ((∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ) - (∫ t in I, ψ t * B t))
        = (∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ) := by
      simpa [add_comm, add_left_comm, add_assoc, sub_eq_add_neg]
        using (sub_add_cancel
          (∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)
          (∫ t in I, ψ t * B t))
    simpa [add_comm, add_left_comm, add_assoc]
      using this.symm
  · simpa using hBound

/-- Project-preferred alias: same statement and proof route. -/
theorem CRGreen_pairing_whitney
  (U : ℝ × ℝ → ℝ) (W ψ : ℝ → ℝ) (χ : ℝ × ℝ → ℝ)
  (I : Set ℝ) (α' : ℝ)
  (σ : Measure (ℝ × ℝ)) (Q : Set (ℝ × ℝ))
  (∇U : (ℝ × ℝ) → ℝ × ℝ) (∇χVψ : (ℝ × ℝ) → ℝ × ℝ)
  (B : ℝ → ℝ) (Cψ : ℝ)
  (hBound :
    |(∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)
      - (∫ t in I, ψ t * B t)| ≤
    Cψ * Real.sqrt (∫ x in Q, sqnormR2 (∇U x) ∂σ)) :
  ∃ R : ℝ,
    (∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)
      = (∫ t in I, ψ t * B t) + R
  ∧ |R| ≤ Cψ * Real.sqrt (∫ x in Q, sqnormR2 (∇U x) ∂σ) :=
  pairing_whitney U W ψ χ I α' σ Q ∇U ∇χVψ B Cψ hBound

/-- Outer cancellation on the boundary (interface form).

Given bounds of CR–Green Whitney type for the difference field `U − U₀`
against a fixed test `χ·Vψ`, we obtain a remainder representation where the
boundary phase term uses the chosen boundary integrand `B` and the interior term
is the difference of the pairings for `U` and `U₀`.

This is purely algebraic packaging: the analytic estimate is provided by the
single hypothesis `hBoundDiff`. -/
theorem outer_cancellation_on_boundary
  (U U₀ : ℝ × ℝ → ℝ) (ψ : ℝ → ℝ) (χ : ℝ × ℝ → ℝ)
  (I : Set ℝ) (α' : ℝ)
  (σ : Measure (ℝ × ℝ)) (Q : Set (ℝ × ℝ))
  (∇U ∇U₀ : (ℝ × ℝ) → ℝ × ℝ) (∇χVψ : (ℝ × ℝ) → ℝ × ℝ)
  (B : ℝ → ℝ) (Cψ : ℝ)
  (hBoundDiff :
    |(∫ x in Q, (( (∇U x).1 - (∇U₀ x).1, (∇U x).2 - (∇U₀ x).2 )) ⋅ (∇χVψ x) ∂σ)
      - (∫ t in I, ψ t * B t)| ≤
    Cψ * Real.sqrt (∫ x in Q, sqnormR2 (( (∇U x).1 - (∇U₀ x).1, (∇U x).2 - (∇U₀ x).2 )) ∂σ)) :
  ∃ R : ℝ,
    (∫ x in Q, (( (∇U x).1 - (∇U₀ x).1, (∇U x).2 - (∇U₀ x).2 )) ⋅ (∇χVψ x) ∂σ)
      = (∫ t in I, ψ t * B t) + R
  ∧ |R| ≤ Cψ * Real.sqrt (∫ x in Q, sqnormR2 (( (∇U x).1 - (∇U₀ x).1, (∇U x).2 - (∇U₀ x).2 )) ∂σ) := by
  classical
  let ∇Udiff : (ℝ × ℝ) → ℝ × ℝ := fun x => ((∇U x).1 - (∇U₀ x).1, (∇U x).2 - (∇U₀ x).2)
  -- Apply the Whitney pairing interface to the difference field
  simpa [∇Udiff] using
    (pairing_whitney (U := fun _ => 0) (W := fun _ => 0) (ψ := ψ) (χ := χ)
      (I := I) (α' := α') (σ := σ) (Q := Q)
      (∇U := ∇Udiff) (∇χVψ := ∇χVψ) (B := B) (Cψ := Cψ) (hBound := hBoundDiff))

/-!
  ------------------------------------------------------------------------
  (1) Analytic Whitney pairing bound:
      |∫_I ψ (−W′)| ≤ Cψ · √( ∬_Q |∇U|² dσ )
  ------------------------------------------------------------------------

  We separate the two analytic ingredients as hypotheses:

    • hPairVol  : Cauchy–Schwarz/test control of the volume pairing
                  |∬_Q ∇U · ∇(χVψ)| ≤ Cψ_pair · √(energy)

    • hRemBound : Whitney remainder control
                  |R| ≤ Cψ_rem · √(energy)

  Then we combine with the algebraic identity BD = LHS − R to get the boundary
  bound with Cψ := Cψ_pair + Cψ_rem.
-/

/-- Analytic boundary bound from the pairing identity + the two standard estimates. -/
theorem pairing_whitney_analytic_bound
  (U : ℝ × ℝ → ℝ) (W ψ : ℝ → ℝ) (χ : ℝ × ℝ → ℝ)
  (I : Set ℝ) (α' : ℝ)
  (σ : Measure (ℝ × ℝ)) (Q : Set (ℝ × ℝ))
  (∇U : (ℝ × ℝ) → ℝ × ℝ)           -- abstract gradient of U
  (∇χVψ : (ℝ × ℝ) → ℝ × ℝ)         -- abstract gradient of χ·Vψ
  (B : ℝ → ℝ)
  (Cψ_pair Cψ_rem : ℝ)
  (hPairVol :
    |∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ|
      ≤ Cψ_pair * Real.sqrt (boxEnergy ∇U σ Q))
  (hRemBound :
    |(∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)
      - (∫ t in I, ψ t * B t)|
      ≤ Cψ_rem * Real.sqrt (boxEnergy ∇U σ Q)) :
  |∫ t in I, ψ t * B t|
    ≤ (Cψ_pair + Cψ_rem) * Real.sqrt (boxEnergy ∇U σ Q) := by
  classical
  set LHS : ℝ := ∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ
  set BD  : ℝ := ∫ t in I, ψ t * B t
  set R   : ℝ := LHS - BD
  have hBD : BD = LHS - R := by
    -- by definition R := LHS - BD
    simp [R, LHS, BD, sub_eq_add_neg, add_comm, add_left_comm, add_assoc]
  -- Triangle inequality on BD = LHS - R
  have tineq : |BD| ≤ |LHS| + |R| := by
    -- |LHS - R| ≤ |LHS| + |R|
    simpa [hBD, sub_eq_add_neg, abs_neg] using (abs_add LHS (-R))
  -- Plug the analytic bounds
  have hR : |R| ≤ Cψ_rem * Real.sqrt (boxEnergy ∇U σ Q) := by
    -- R = LHS - BD, so the given remainder bound is exactly |R| ≤ ...
    simpa [R, LHS, BD]
      using hRemBound
  have hSum :
      |LHS| + |R|
        ≤ (Cψ_pair + Cψ_rem) * Real.sqrt (boxEnergy ∇U σ Q) := by
    have : |LHS| + |R|
            ≤ Cψ_pair * Real.sqrt (boxEnergy ∇U σ Q)
              + Cψ_rem * Real.sqrt (boxEnergy ∇U σ Q) := by
      exact add_le_add hPairVol hR
    -- (Cψ_pair + Cψ_rem) * s = Cψ_pair*s + Cψ_rem*s
    simpa [add_mul]
      using this
  exact (le_trans tineq hSum)

/-
  ------------------------------------------------------------------------
  (2) Concrete Half-Plane Carleson step:
      plug ∬_Q |∇U|² ≤ Kξ · |I| into the analytic bound to get the link.
  ------------------------------------------------------------------------

  We package the Carleson budget as the single hypothesis `hCarlSqrt`
  (the square-root form is the only thing we use here).
-/

/-- Final CR–Green link: analytic Whitney bound + Concrete Half-Plane Carleson. -/
theorem CRGreen_link
  (U : ℝ × ℝ → ℝ) (W ψ : ℝ → ℝ) (χ : ℝ × ℝ → ℝ)
  (I : Set ℝ) (α' : ℝ)
  (σ : Measure (ℝ × ℝ)) (Q : Set (ℝ × ℝ))
  (∇U : (ℝ × ℝ) → ℝ × ℝ) (∇χVψ : (ℝ × ℝ) → ℝ × ℝ)
  (B : ℝ → ℝ)
  (Cψ_pair Cψ_rem : ℝ)
  -- Analytic pairing bounds (as in `pairing_whitney_analytic_bound`):
  (hPairVol :
    |∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ|
      ≤ Cψ_pair * Real.sqrt (boxEnergy ∇U σ Q))
  (hRemBound :
    |(∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)
      - (∫ t in I, ψ t * B t)|
      ≤ Cψ_rem * Real.sqrt (boxEnergy ∇U σ Q))
  -- Concrete Half-Plane Carleson budget, delivered in the sqrt form:
  (Kξ lenI : ℝ) (hCψ_nonneg : 0 ≤ Cψ_pair + Cψ_rem)
  (hCarlSqrt :
    Real.sqrt (boxEnergy ∇U σ Q) ≤ Real.sqrt (Kξ * lenI)) :
  |∫ t in I, ψ t * B t| ≤ (Cψ_pair + Cψ_rem) * Real.sqrt (Kξ * lenI) := by
  -- First, the analytic Whitney bound:
  have hAnalytic :
      |∫ t in I, ψ t * B t|
        ≤ (Cψ_pair + Cψ_rem) * Real.sqrt (boxEnergy ∇U σ Q) :=
    pairing_whitney_analytic_bound
      U W ψ χ I α' σ Q ∇U ∇χVψ B
      Cψ_pair Cψ_rem hPairVol hRemBound
  -- Then push through the Carleson budget (monotone for nonnegative constants):
  exact
    (le_trans hAnalytic
      (by
        have := hCarlSqrt
        exact mul_le_mul_of_nonneg_left this hCψ_nonneg))

/-- RS-level wrapper: a ConcreteHalfPlaneCarleson budget yields the sqrt box-energy
bound used by `CRGreen_link` on any Whitney box `Q` over interval `I`, with
`lenI` representing |I| (the length proxy used in the downstream inequality).

This is a packaging lemma: it re-expresses the `RH.Cert.ConcreteHalfPlaneCarleson`
predicate in the square-root form needed by the pairing link.

Note: The detailed identification between `Q`, `I`, and the energy integral
appears in your geometry layer. Here we only expose the numeric implication. -/
theorem sqrt_boxEnergy_bound_of_ConcreteHalfPlaneCarleson
  {Kξ lenI : ℝ}
  (hCar : RH.Cert.ConcreteHalfPlaneCarleson Kξ)
  (∇U : (ℝ × ℝ) → ℝ × ℝ)
  (σ : Measure (ℝ × ℝ))
  (Q : Set (ℝ × ℝ))
  (hEnergy_le : boxEnergy ∇U σ Q ≤ Kξ * lenI)
  : Real.sqrt (boxEnergy ∇U σ Q) ≤ Real.sqrt (Kξ * lenI) := by
  -- Monotonicity of `Real.sqrt` on ℝ≥0; the Carleson predicate provides `0 ≤ Kξ`.
  have _hK : 0 ≤ Kξ := hCar.left
  exact Real.sqrt_le_sqrt hEnergy_le

/-- Practical wrapper: if the geometry supplies
`boxEnergy ≤ (RH.Cert.mkWhitneyBoxEnergy W Kξ).bound`, then the Carleson
predicate yields the desired sqrt budget with `lenI = 2*W.len`. -/
theorem sqrt_boxEnergy_from_Carleson_on_whitney
  {Kξ : ℝ}
  (hCar : RH.Cert.ConcreteHalfPlaneCarleson Kξ)
  (W : RH.Cert.WhitneyInterval)
  (∇U : (ℝ × ℝ) → ℝ × ℝ)
  (σ : Measure (ℝ × ℝ))
  (Q : Set (ℝ × ℝ))
  (hGeom : boxEnergy ∇U σ Q ≤ (RH.Cert.mkWhitneyBoxEnergy W Kξ).bound)
  : Real.sqrt (boxEnergy ∇U σ Q) ≤ Real.sqrt (Kξ * (2 * W.len)) := by
  have hBudget := (hCar.right W)
  have hEnergy : boxEnergy ∇U σ Q ≤ Kξ * (2 * W.len) :=
    le_trans hGeom hBudget
  exact Real.sqrt_le_sqrt hEnergy

/- ### Concrete Green + trace packaging → pairing bound (algebraic)

This lemma replaces the abstract `hBound` by a Green identity with two
remainders (`Rside`, `Rtop`) and separate trace bounds. It is purely
algebraic, using triangle inequality and distributivity to obtain the
Whitney pairing bound.
-/

theorem CRGreen_pairing_from_green_and_trace
  (U : ℝ × ℝ → ℝ) (W ψ : ℝ → ℝ) (χ : ℝ × ℝ → ℝ)
  (I : Set ℝ)
  (σ : Measure (ℝ × ℝ)) (Q : Set (ℝ × ℝ))
  (∇U : (ℝ × ℝ) → ℝ × ℝ) (∇χVψ : (ℝ × ℝ) → ℝ × ℝ)
  (B : ℝ → ℝ)
  (Ebox Etest : ℝ) (Cside Ctop Cψ : ℝ)
  (hEq :
    ∃ Rside Rtop : ℝ,
      (∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)
        = (∫ t in I, ψ t * B t) + Rside + Rtop)
  (hRside : ∀ Rside, |Rside| ≤ Cside * Real.sqrt Ebox * Real.sqrt Etest)
  (hRtop  : ∀ Rtop,  |Rtop|  ≤ Ctop  * Real.sqrt Ebox * Real.sqrt Etest)
  (hCsum : Cside + Ctop ≤ Cψ)
  : ∃ R : ℝ,
      (∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)
        = (∫ t in I, ψ t * B t) + R
    ∧ |R| ≤ Cψ * Real.sqrt Ebox * Real.sqrt Etest := by
  rcases hEq with ⟨Rside, Rtop, hEq0⟩
  refine ⟨Rside + Rtop, by simpa [add_comm, add_left_comm, add_assoc] using hEq0, ?_⟩
  -- Triangle inequality and factorization
  have hXnonneg : 0 ≤ Real.sqrt Ebox * Real.sqrt Etest :=
    mul_nonneg (Real.sqrt_nonneg _) (Real.sqrt_nonneg _)
  have hsum : |Rside + Rtop| ≤ |Rside| + |Rtop| := by
    simpa using (abs_add_le_abs_add_abs Rside Rtop)
  have h1 : |Rside| ≤ Cside * (Real.sqrt Ebox * Real.sqrt Etest) := by
    simpa [mul_comm, mul_left_comm, mul_assoc] using (hRside Rside)
  have h2 : |Rtop| ≤ Ctop * (Real.sqrt Ebox * Real.sqrt Etest) := by
    simpa [mul_comm, mul_left_comm, mul_assoc] using (hRtop Rtop)
  have hsum' : |Rside| + |Rtop|
      ≤ Cside * (Real.sqrt Ebox * Real.sqrt Etest)
        + Ctop * (Real.sqrt Ebox * Real.sqrt Etest) :=
    add_le_add h1 h2
  have hdist :
      Cside * (Real.sqrt Ebox * Real.sqrt Etest)
        + Ctop * (Real.sqrt Ebox * Real.sqrt Etest)
        = (Cside + Ctop) * (Real.sqrt Ebox * Real.sqrt Etest) := by
    -- (a*X) + (b*X) = (a+b)*X
    have := add_mul Cside Ctop (Real.sqrt Ebox * Real.sqrt Etest)
    simpa [mul_comm, mul_left_comm, mul_assoc] using this.symm
  have h3 : |Rside + Rtop| ≤ (Cside + Ctop) * (Real.sqrt Ebox * Real.sqrt Etest) := by
    refine (le_trans hsum ?_)
    simpa [hdist]
      using hsum'
  have h4 : (Cside + Ctop) * (Real.sqrt Ebox * Real.sqrt Etest)
      ≤ Cψ * (Real.sqrt Ebox * Real.sqrt Etest) :=
    mul_le_mul_of_nonneg_right hCsum hXnonneg
  exact (le_trans h3 h4)

/- Alias with project-style name and order. -/
theorem CRGreen_pairing_whitney_from_green_trace
  (U : ℝ × ℝ → ℝ) (W ψ : ℝ → ℝ) (χ : ℝ × ℝ → ℝ)
  (I : Set ℝ)
  (σ : Measure (ℝ × ℝ)) (Q : Set (ℝ × ℝ))
  (∇U : (ℝ × ℝ) → ℝ × ℝ) (∇χVψ : (ℝ × ℝ) → ℝ × ℝ)
  (B : ℝ → ℝ)
  (Ebox Etest : ℝ) (Cside Ctop Cψ : ℝ)
  (hEq :
    ∃ Rside Rtop : ℝ,
      (∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)
        = (∫ t in I, ψ t * B t) + Rside + Rtop)
  (hRside : ∀ Rside, |Rside| ≤ Cside * Real.sqrt Ebox * Real.sqrt Etest)
  (hRtop  : ∀ Rtop,  |Rtop|  ≤ Ctop  * Real.sqrt Ebox * Real.sqrt Etest)
  (hCsum : Cside + Ctop ≤ Cψ)
  : ∃ R : ℝ,
      (∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)
        = (∫ t in I, ψ t * B t) + R
    ∧ |R| ≤ Cψ * Real.sqrt Ebox * Real.sqrt Etest :=
  CRGreen_pairing_from_green_and_trace U W ψ χ I σ Q ∇U ∇χVψ B Ebox Etest Cside Ctop Cψ
    hEq hRside hRtop hCsum

end RS
end RH

/-!
Add-on: convenient test-energy alias, Whitney side/top remainder folding,
and a clean boundary CR trace lemma.
-/

noncomputable section

namespace RH
namespace RS

open Real Set MeasureTheory
open scoped MeasureTheory

/-- Convenience alias: treat the test field energy with the same integrand. -/
@[simp] def testEnergy
  (∇χVψ : (ℝ × ℝ) → ℝ × ℝ) (σ : Measure (ℝ × ℝ)) (Q : Set (ℝ × ℝ)) : ℝ :=
  boxEnergy ∇χVψ σ Q

/-- Fold two Whitney remainder controls into the one-sqrt remainder form used by `CRGreen_link`.

Assumptions deliver the identity with two remainders and L²×L² bounds on each;
we then obtain the bound on `|LHS − BD|` with constant `((Cside + Ctop) * √Etest)`.
-/
theorem hRemBound_from_side_top
  (U : ℝ × ℝ → ℝ) (ψ : ℝ → ℝ) (χ : ℝ × ℝ → ℝ)
  (I : Set ℝ)
  (σ : Measure (ℝ × ℝ)) (Q : Set (ℝ × ℝ))
  (∇U : (ℝ × ℝ) → ℝ × ℝ) (∇χVψ : (ℝ × ℝ) → ℝ × ℝ)
  (B : ℝ → ℝ)
  (Etest Cside Ctop : ℝ)
  (hEq :
    ∃ Rside Rtop : ℝ,
      (∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)
        = (∫ t in I, ψ t * B t) + Rside + Rtop)
  (hRside :
    ∀ Rside, |Rside| ≤ Cside * Real.sqrt (boxEnergy ∇U σ Q) * Real.sqrt Etest)
  (hRtop  :
    ∀ Rtop,  |Rtop|  ≤ Ctop  * Real.sqrt (boxEnergy ∇U σ Q) * Real.sqrt Etest)
  :
  |(∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)
     - (∫ t in I, ψ t * B t)|
    ≤ ((Cside + Ctop) * Real.sqrt Etest) * Real.sqrt (boxEnergy ∇U σ Q) := by
  classical
  rcases hEq with ⟨Rside, Rtop, hEq0⟩
  have hR : (∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)
              - (∫ t in I, ψ t * B t)
            = Rside + Rtop := by
    simpa [sub_eq_iff_eq_add] using hEq0
  have hsum : |Rside + Rtop| ≤ |Rside| + |Rtop| := by
    simpa using (abs_add_le_abs_add_abs Rside Rtop)
  have h1 :
      |Rside| ≤ Cside * (Real.sqrt (boxEnergy ∇U σ Q) * Real.sqrt Etest) := by
    simpa [mul_comm, mul_left_comm, mul_assoc] using (hRside Rside)
  have h2 :
      |Rtop| ≤ Ctop * (Real.sqrt (boxEnergy ∇U σ Q) * Real.sqrt Etest) := by
    simpa [mul_comm, mul_left_comm, mul_assoc] using (hRtop Rtop)
  have hsum' :
      |Rside| + |Rtop|
        ≤ (Cside + Ctop) * (Real.sqrt (boxEnergy ∇U σ Q) * Real.sqrt Etest) := by
    simpa [add_mul, mul_comm, mul_left_comm, mul_assoc] using add_le_add h1 h2
  have hfin :
      |Rside + Rtop|
        ≤ ((Cside + Ctop) * Real.sqrt Etest) * Real.sqrt (boxEnergy ∇U σ Q) := by
    simpa [mul_comm, mul_left_comm, mul_assoc] using hsum'
  simpa [hR]

/-- Optional boundary CR trace swap: if on `I` we have `ψ·B =ᵐ ψ·(−W′)`, then
the bottom-edge term equals `−∫_I ψ·W′`.

This is a pure `ae` congruence of integrands over the restricted measure. -/
theorem boundary_CR_trace_ae
  (I : Set ℝ) (ψ W : ℝ → ℝ) (B : ℝ → ℝ)
  (h_ae :
    (fun t => ψ t * B t)
      =ᵐ[Measure.restrict (volume) I]
    (fun t => ψ t * (-(deriv W t))))
  :
  (∫ t in I, ψ t * B t)
    = - (∫ t in I, ψ t * (deriv W t)) := by
  have : (∫ t in I, ψ t * B t)
           = (∫ t in I, ψ t * (-(deriv W t))) := by
    exact integral_congr_ae h_ae
  simpa [this, integral_neg, mul_comm, mul_left_comm, mul_assoc]

/-- L² Hölder (Cauchy–Schwarz) on the restricted measure μ := σ|_Q.

It provides the volume/test bound input `hPairVol` for `CRGreen_link`
with the constant `Cψ_pair := √(testEnergy ∇χVψ σ Q)`.
-/
theorem hPairVol_of_L2_holder
  (σ : Measure (ℝ × ℝ)) (Q : Set (ℝ × ℝ))
  (∇U ∇χVψ : (ℝ × ℝ) → ℝ × ℝ)
  :
  |∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ|
    ≤ (Real.sqrt (testEnergy ∇χVψ σ Q)) * Real.sqrt (boxEnergy ∇U σ Q) := by
  classical
  -- Use the coordinate split and L² CS for each coordinate, then compress in ℝ²
  -- as in the decomposition described; finish by identifying the energies.
  -- We reuse the algebraic argument within this file.
  -- Define restricted measure μ.
  set μ : Measure (ℝ × ℝ) := Measure.restrict σ Q
  -- Coordinate CS bounds
  -- Coordinate L¹ bound by Hölder p=q=2: ∫ |f g| ≤ ‖f‖₂ ‖g‖₂
  have h1 :
      |∫ x, (∇U x).1 * (∇χVψ x).1 ∂μ|
        ≤ Real.sqrt (∫ x, ((∇U x).1)^2 ∂μ)
            * Real.sqrt (∫ x, ((∇χVψ x).1)^2 ∂μ) := by
    have hL1 :
        (∫ x, |(∇U x).1 * (∇χVψ x).1| ∂μ)
          ≤ snorm (fun x => (∇U x).1) (2 : ℝ≥0∞) μ
              * snorm (fun x => (∇χVψ x).1) (2 : ℝ≥0∞) μ := by
      simpa using
        (snorm_mul_le
          (f := fun x => (∇U x).1) (g := fun x => (∇χVψ x).1)
          (μ := μ) (hpq := by simp) (hpm := by simp) (hqm := by simp))
    have habs :
        |∫ x, (∇U x).1 * (∇χVψ x).1 ∂μ|
          ≤ (∫ x, |(∇U x).1 * (∇χVψ x).1| ∂μ) :=
      by simpa using (abs_integral_le_integral_abs (μ := μ)
        (f := fun x => (∇U x).1 * (∇χVψ x).1))
    have hsn1 : snorm (fun x => (∇U x).1) (2 : ℝ≥0∞) μ
        = Real.sqrt (∫ x, ((∇U x).1)^2 ∂μ) := by
      simpa [snorm, Real.rpow_two, one_div, inv_two, ENNReal.toReal_ofReal, sq_abs]
        using (snorm_congr_ae (μ := μ)
          (f := fun x => (∇U x).1) (g := fun x => (∇U x).1)
          (by simp))
    have hsn2 : snorm (fun x => (∇χVψ x).1) (2 : ℝ≥0∞) μ
        = Real.sqrt (∫ x, ((∇χVψ x).1)^2 ∂μ) := by
      simpa [snorm, Real.rpow_two, one_div, inv_two, ENNReal.toReal_ofReal, sq_abs]
        using (snorm_congr_ae (μ := μ)
          (f := fun x => (∇χVψ x).1) (g := fun x => (∇χVψ x).1)
          (by simp))
    have :=
      calc
        |∫ x, (∇U x).1 * (∇χVψ x).1 ∂μ|
            ≤ (∫ x, |(∇U x).1 * (∇χVψ x).1| ∂μ) := habs
        _ ≤ snorm (fun x => (∇U x).1) 2 μ * snorm (fun x => (∇χVψ x).1) 2 μ := hL1
    simpa [hsn1, hsn2] using this
  have h2 :
      |∫ x, (∇U x).2 * (∇χVψ x).2 ∂μ|
        ≤ Real.sqrt (∫ x, ((∇U x).2)^2 ∂μ)
            * Real.sqrt (∫ x, ((∇χVψ x).2)^2 ∂μ) := by
    have hL1 :
        (∫ x, |(∇U x).2 * (∇χVψ x).2| ∂μ)
          ≤ snorm (fun x => (∇U x).2) (2 : ℝ≥0∞) μ
              * snorm (fun x => (∇χVψ x).2) (2 : ℝ≥0∞) μ := by
      simpa using
        (snorm_mul_le
          (f := fun x => (∇U x).2) (g := fun x => (∇χVψ x).2)
          (μ := μ) (hpq := by simp) (hpm := by simp) (hqm := by simp))
    have habs :
        |∫ x, (∇U x).2 * (∇χVψ x).2 ∂μ|
          ≤ (∫ x, |(∇U x).2 * (∇χVψ x).2| ∂μ) :=
      by simpa using (abs_integral_le_integral_abs (μ := μ)
        (f := fun x => (∇U x).2 * (∇χVψ x).2))
    have hsn1 : snorm (fun x => (∇U x).2) (2 : ℝ≥0∞) μ
        = Real.sqrt (∫ x, ((∇U x).2)^2 ∂μ) := by
      simpa [snorm, Real.rpow_two, one_div, inv_two, ENNReal.toReal_ofReal, sq_abs]
        using (snorm_congr_ae (μ := μ)
          (f := fun x => (∇U x).2) (g := fun x => (∇U x).2)
          (by simp))
    have hsn2 : snorm (fun x => (∇χVψ x).2) (2 : ℝ≥0∞) μ
        = Real.sqrt (∫ x, ((∇χVψ x).2)^2 ∂μ) := by
      simpa [snorm, Real.rpow_two, one_div, inv_two, ENNReal.toReal_ofReal, sq_abs]
        using (snorm_congr_ae (μ := μ)
          (f := fun x => (∇χVψ x).2) (g := fun x => (∇χVψ x).2)
          (by simp))
    have :=
      calc
        |∫ x, (∇U x).2 * (∇χVψ x).2 ∂μ|
            ≤ (∫ x, |(∇U x).2 * (∇χVψ x).2| ∂μ) := habs
        _ ≤ snorm (fun x => (∇U x).2) 2 μ * snorm (fun x => (∇χVψ x).2) 2 μ := hL1
    simpa [hsn1, hsn2] using this
  -- Split pairing into coordinates under σ|_Q
  have hsplit :
      (∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)
        = (∫ x, (∇U x).1 * (∇χVψ x).1 ∂μ)
            + (∫ x, (∇U x).2 * (∇χVψ x).2 ∂μ) := by
    have := integral_add
      (μ := μ)
      (f := fun x => (∇U x).1 * (∇χVψ x).1)
      (g := fun x => (∇U x).2 * (∇χVψ x).2)
    simpa [μ, dotR2, integral_add, Set.indicator, Measure.restrict_apply, inter_univ]
      using this
  -- Triangle inequality plus the two CS bounds
  have htri :
      |(∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)|
        ≤ |∫ x, (∇U x).1 * (∇χVψ x).1 ∂μ|
          + |∫ x, (∇U x).2 * (∇χVψ x).2 ∂μ| := by
    simpa [hsplit] using abs_add
      (∫ x, (∇U x).1 * (∇χVψ x).1 ∂μ)
      (∫ x, (∇U x).2 * (∇χVψ x).2 ∂μ)
  -- Define the four L² norms
  set a := Real.sqrt (∫ x, ((∇U x).1)^2 ∂μ)
  set b := Real.sqrt (∫ x, ((∇U x).2)^2 ∂μ)
  set c := Real.sqrt (∫ x, ((∇χVψ x).1)^2 ∂μ)
  set d := Real.sqrt (∫ x, ((∇χVψ x).2)^2 ∂μ)
  have hsum : |(∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)| ≤ a * c + b * d :=
    le_trans htri (add_le_add h1 h2)
  -- CS in ℝ²
  have hcs2 : a * c + b * d ≤ Real.sqrt (a^2 + b^2) * Real.sqrt (c^2 + d^2) := by
    have : |a * c + b * d| ≤ Real.sqrt (a^2 + b^2) * Real.sqrt (c^2 + d^2) := by
      simpa using (abs_real_inner_le_norm (x := (a, b)) (y := (c, d)))
    have hnonneg : 0 ≤ a * c + b * d := by
      have ha := Real.sqrt_nonneg _; have hb := Real.sqrt_nonneg _
      have hc := Real.sqrt_nonneg _; have hd := Real.sqrt_nonneg _
      simpa using add_nonneg (mul_nonneg ha hc) (mul_nonneg hb hd)
    simpa [abs_of_nonneg hnonneg]
      using this
  -- Identify energies
  have ha2 : Real.sqrt (a^2 + b^2) = Real.sqrt (∫ x, sqnormR2 (∇U x) ∂μ) := by
    -- identical expansion as used above in this file
    have ha' : a^2 = ∫ x, ((∇U x).1)^2 ∂μ := by
      have : 0 ≤ ∫ x, ((∇U x).1)^2 ∂μ :=
        integral_nonneg (by intro x; simpa using sq_nonneg _)
      simpa [a, Real.sq, this, Real.mul_self_sqrt]
    have hb' : b^2 = ∫ x, ((∇U x).2)^2 ∂μ := by
      have : 0 ≤ ∫ x, ((∇U x).2)^2 ∂μ :=
        integral_nonneg (by intro x; simpa using sq_nonneg _)
      simpa [b, Real.sq, this, Real.mul_self_sqrt]
    have : (∫ x, ((∇U x).1)^2 ∂μ) + (∫ x, ((∇U x).2)^2 ∂μ)
            = ∫ x, (((∇U x).1)^2 + ((∇U x).2)^2) ∂μ := by
      have h₁ := integral_add (μ := μ)
        (f := fun x => ((∇U x).1)^2) (g := fun x => ((∇U x).2)^2)
      simpa [sqnormR2, integral_add] using h₁
    have : a^2 + b^2 = ∫ x, sqnormR2 (∇U x) ∂μ := by
      simpa [ha', hb', sqnormR2]
        using this
    simpa [this]
  have hc2 : Real.sqrt (c^2 + d^2) = Real.sqrt (∫ x, sqnormR2 (∇χVψ x) ∂μ) := by
    have hc' : c^2 = ∫ x, ((∇χVψ x).1)^2 ∂μ := by
      have : 0 ≤ ∫ x, ((∇χVψ x).1)^2 ∂μ :=
        integral_nonneg (by intro x; simpa using sq_nonneg _)
      simpa [c, Real.sq, this, Real.mul_self_sqrt]
    have hd' : d^2 = ∫ x, ((∇χVψ x).2)^2 ∂μ := by
      have : 0 ≤ ∫ x, ((∇χVψ x).2)^2 ∂μ :=
        integral_nonneg (by intro x; simpa using sq_nonneg _)
      simpa [d, Real.sq, this, Real.mul_self_sqrt]
    have : (∫ x, ((∇χVψ x).1)^2 ∂μ) + (∫ x, ((∇χVψ x).2)^2 ∂μ)
            = ∫ x, (((∇χVψ x).1)^2 + ((∇χVψ x).2)^2) ∂μ := by
      have h₁ := integral_add (μ := μ)
        (f := fun x => ((∇χVψ x).1)^2) (g := fun x => ((∇χVψ x).2)^2)
      simpa [sqnormR2, integral_add] using h₁
    have : c^2 + d^2 = ∫ x, sqnormR2 (∇χVψ x) ∂μ := by
      simpa [hc', hd', sqnormR2]
        using this
    simpa [this]
  -- Conclude and rewrite back to set-integral form.
  have : |(∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ)|
            ≤ Real.sqrt (∫ x, sqnormR2 (∇U x) ∂μ)
                * Real.sqrt (∫ x, sqnormR2 (∇χVψ x) ∂μ) :=
    le_trans hsum (by simpa [ha2, hc2] using hcs2)
  simpa [μ, boxEnergy, testEnergy, Measure.restrict_apply, inter_univ]
    using this

/- The actual volume pairing over Q. -/
@[simp] def realPairingValue
  (σ : Measure (ℝ × ℝ)) (Q : Set (ℝ × ℝ))
  (∇U ∇χVψ : (ℝ × ℝ) → ℝ × ℝ) : ℝ :=
  ∫ x in Q, (∇U x) ⋅ (∇χVψ x) ∂σ

/-- Cutoff pairing bound (Cauchy–Schwarz/L² Hölder). -/
theorem real_cutoff_pairing_bound
  (σ : Measure (ℝ × ℝ)) (Q : Set (ℝ × ℝ))
  (∇U ∇χVψ : (ℝ × ℝ) → ℝ × ℝ) :
  ∃ Crem : ℝ, 0 ≤ Crem ∧
    |realPairingValue σ Q ∇U ∇χVψ|
      ≤ Crem * Real.sqrt (boxEnergy ∇U σ Q) * Real.sqrt (testEnergy ∇χVψ σ Q) := by
  refine ⟨1, by norm_num, ?_⟩
  -- `hPairVol_of_L2_holder` already gives |⟨∇U,∇χVψ⟩| ≤ √E_test · √E_box.
  -- Commute factors to match the target RHS shape.
  simpa [realPairingValue, testEnergy, mul_comm, mul_left_comm, mul_assoc]
    using (hPairVol_of_L2_holder σ Q ∇U ∇χVψ)

end RS
end RH
